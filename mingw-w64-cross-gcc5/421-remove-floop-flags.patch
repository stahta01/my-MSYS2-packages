From 54db0e6e444fcb88eb0a2857444cc181d2b3f896 Mon Sep 17 00:00:00 2001
From: Tim Stahlhut <stahta01@gmail.com>
Date: Thu, 16 Jul 2020 12:38:19 -0400
Subject: Partial Backport of SVN 227277

2015-08-27  Sebastian Pop  <s.pop@samsung.com>

remove -floop-* flags

	* Makefile.in (OBJS): Remove graphite-blocking.o and
	graphite-interchange.o.
	* common.opt (floop-strip-mine, floop-interchange, floop-block):
	Alias of floop-nest-optimize.
	* doc/invoke.texi (floop-strip-mine, floop-interchange, floop-block):
	Document as alias of -floop-nest-optimize.
	* graphite-blocking.c: Remove.
	* graphite-interchange.c: Remove.
	* graphite-optimize-isl.c: Include dumpfile.h.
	(getScheduleForBand): Add dump for tiled loops.  Use
	PARAM_LOOP_BLOCK_TILE_SIZE instead of hard coded constant.
	* graphite-poly.c (scop_max_loop_depth): Remove.
	(print_scattering_function_1): Remove.
	(print_scattering_function): Remove.
	(print_scattering_functions): Remove.
	(debug_scattering_function): Remove.
	(debug_scattering_functions): Remove.
	(apply_poly_transforms): Remove use of flag_loop_block,
	flag_loop_strip_mine, and flag_loop_interchange.
	(new_poly_bb): Remove use of PBB_TRANSFORMED, PBB_SAVED, and
	PBB_ORIGINAL.
	(print_pdr_access_layout): Remove.
	(print_pdr): Print ISL representation.
	(new_scop): Remove use of SCOP_ORIGINAL_SCHEDULE,
	SCOP_TRANSFORMED_SCHEDULE, and SCOP_SAVED_SCHEDULE.
	(free_scop): Same.
	(openscop_print_pbb_domain): Remove.
	(print_pbb): Remove call to print_scattering_function.
	(openscop_print_scop_context): Remove.
	(print_scop_context): Do not print matrices anymore.
	(print_scop): Do not print SCOP_ORIGINAL_SCHEDULE and
	SCOP_TRANSFORMED_SCHEDULE.
	(print_isl_set): Add printing of a new line.
	(print_isl_map): Same.
	(print_isl_aff): Same.
	(print_isl_constraint): Same.
	(loop_to_lst): Remove.
	(scop_to_lst): Remove.
	(lst_indent_to): Remove.
	(print_lst): Remove.
	(debug_lst): Remove.
	(dot_lst_1): Remove.
	(dot_lst): Remove.
	(reverse_loop_at_level): Remove.
	(reverse_loop_for_pbbs): Remove.
	* graphite-poly.h (pdr_dim_iter_domain): Remove.
	(pdr_nb_params): Remove.
	(pdr_alias_set_dim): Remove.
	(pdr_subscript_dim): Remove.
	(pdr_iterator_dim): Remove.
	(pdr_parameter_dim): Remove.
	(same_pdr_p): Remove.
	(struct poly_scattering): Remove.
	(struct poly_bb): Remove _original, _transformed, _saved.
	(PBB_DOMAIN, PBB_ORIGINAL, PBB_ORIGINAL_SCATTERING): Remove.
	(PBB_TRANSFORMED, PBB_TRANSFORMED_SCATTERING, PBB_SAVED): Remove.
	(PBB_NB_LOCAL_VARIABLES): Remove.
	(PBB_NB_SCATTERING_TRANSFORM): Remove.
	(schedule_to_scattering): Remove.
	(number_of_write_pdrs): Remove.
	(pbb_dim_iter_domain): Remove.
	(pbb_nb_params): Remove.
	(pbb_nb_scattering_orig): Remove.
	(pbb_nb_scattering_transform): Remove.
	(pbb_nb_dynamic_scattering_transform): Remove.
	(pbb_nb_local_vars): Remove.
	(pbb_iterator_dim): Remove.
	(pbb_parameter_dim): Remove.
	(psco_scattering_dim): Remove.
	(psct_scattering_dim): Remove.
	(psct_local_var_dim): Remove.
	(psco_iterator_dim): Remove.
	(psct_iterator_dim): Remove.
	(psco_parameter_dim): Remove.
	(psct_parameter_dim): Remove.
	(psct_dynamic_dim): Remove.
	(psct_static_dim): Remove.
	(psct_add_local_variable): Remove.
	(new_lst_loop): Remove.
	(new_lst_stmt): Remove.
	(free_lst): Remove.
	(copy_lst): Remove.
	(lst_add_loop_under_loop): Remove.
	(lst_depth): Remove.
	(lst_dewey_number): Remove.
	(lst_dewey_number_at_depth): Remove.
	(lst_pred): Remove.
	(lst_succ): Remove.
	(lst_find_pbb): Remove.
	(find_lst_loop): Remove.
	(lst_find_first_pbb): Remove.
	(lst_empty_p): Remove.
	(lst_find_last_pbb): Remove.
	(lst_contains_p): Remove.
	(lst_contains_pbb): Remove.
	(lst_create_nest): Remove.
	(lst_remove_from_sequence): Remove.
	(lst_remove_loop_and_inline_stmts_in_loop_father): Remove.
	(lst_niter_for_loop): Remove.
	(pbb_update_scattering): Remove.
	(lst_update_scattering_under): Remove.
	(lst_update_scattering): Remove.
	(lst_insert_in_sequence): Remove.
	(lst_replace): Remove.
	(lst_substitute_3): Remove.
	(lst_distribute_lst): Remove.
	(lst_remove_all_before_including_pbb): Remove.
	(lst_remove_all_before_excluding_pbb): Remove.
	(struct scop): Remove original_schedule, transformed_schedule, and
	saved_schedule.
	(SCOP_ORIGINAL_SCHEDULE, SCOP_TRANSFORMED_SCHEDULE): Remove.
	(SCOP_SAVED_SCHEDULE): Remove.
	(poly_scattering_new): Remove.
	(poly_scattering_free): Remove.
	(poly_scattering_copy): Remove.
	(store_scattering_pbb): Remove.
	(store_lst_schedule): Remove.
	(restore_lst_schedule): Remove.
	(store_scattering): Remove.
	(restore_scattering_pbb): Remove.
	(restore_scattering): Remove.
	* graphite-sese-to-poly.c (build_pbb_scattering_polyhedrons):
	Remove scattering_dimensions.  Do not use pbb_dim_iter_domain:
	compute the scattering polyhedron dimension from the dimension of
	pbb->domain.
	(build_scop_scattering): Update call to
	build_pbb_scattering_polyhedrons.
	(build_poly_scop): Remove call to scop_to_lst.
	* graphite.c (graphite_transform_loops): Add call to print_scop.
	(gate_graphite_transforms): Remove use of flag_loop_block,
	flag_loop_interchange, and flag_loop_strip_mine.
---
 gcc/Makefile.in             |    2 -
 gcc/common.opt              |   16 +-
 gcc/doc/invoke.texi         |  108 +---
 gcc/graphite-optimize-isl.c |   13 +-
 gcc/graphite-poly.c         |  490 +---------------
 gcc/graphite-poly.h         | 1082 -----------------------------------
 gcc/graphite-sese-to-poly.c |   22 +-
 gcc/graphite.c              |   15 +-
 8 files changed, 49 insertions(+), 1699 deletions(-)

diff --git a/gcc/Makefile.in b/gcc/Makefile.in
index 4e72d89b308..27a152c3394 100644
--- a/gcc/Makefile.in
+++ b/gcc/Makefile.in
@@ -1265,10 +1265,8 @@ OBJS = \
 	graph.o \
 	graphds.o \
 	graphite.o \
-	graphite-blocking.o \
 	graphite-isl-ast-to-gimple.o \
 	graphite-dependences.o \
-	graphite-interchange.o \
 	graphite-optimize-isl.o \
 	graphite-poly.o \
 	graphite-scop-detection.o \
diff --git a/gcc/common.opt b/gcc/common.opt
index a3240ae6aae..8f94c8e8ba3 100644
--- a/gcc/common.opt
+++ b/gcc/common.opt
@@ -1321,16 +1321,16 @@ Common Report Var(flag_loop_parallelize_all) Optimization
 Mark all loops as parallel
 
 floop-strip-mine
-Common Report Var(flag_loop_strip_mine) Optimization
-Enable Loop Strip Mining transformation
+Common Alias(floop-nest-optimize)
+Enable loop nest transforms.  Same as -floop-nest-optimize
 
 floop-interchange
-Common Report Var(flag_loop_interchange) Optimization
-Enable Loop Interchange transformation
+Common Alias(floop-nest-optimize)
+Enable loop nest transforms.  Same as -floop-nest-optimize
 
 floop-block
-Common Report Var(flag_loop_block) Optimization
-Enable Loop Blocking transformation
+Common Alias(floop-nest-optimize)
+Enable loop nest transforms.  Same as -floop-nest-optimize
 
 floop-unroll-and-jam
 Common Alias(floop-nest-optimize)
@@ -2291,8 +2291,8 @@ Common Report Var(flag_tree_loop_im) Init(1) Optimization
 Enable loop invariant motion on trees
 
 ftree-loop-linear
-Common Alias(floop-interchange)
-Enable loop interchange transforms.  Same as -floop-interchange
+Common Alias(floop-nest-optimize)
+Enable loop nest transforms.  Same as -floop-nest-optimize
 
 ftree-loop-ivcanon
 Common Report Var(flag_tree_loop_ivcanon) Init(1) Optimization
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index 3747770c62f..51bd7d3f7e0 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -8609,102 +8609,19 @@ Perform loop optimizations on trees.  This flag is enabled by default
 at @option{-O} and higher.
 
 @item -ftree-loop-linear
+@itemx -floop-interchange
+@itemx -floop-strip-mine
+@itemx -floop-block
+@itemx -floop-unroll-and-jam
 @opindex ftree-loop-linear
-Perform loop interchange transformations on tree.  Same as
-@option{-floop-interchange}.  To use this code transformation, GCC has
-to be configured with @option{--with-isl} to enable the Graphite loop
-transformation infrastructure.
-
-@item -floop-interchange
 @opindex floop-interchange
-Perform loop interchange transformations on loops.  Interchanging two
-nested loops switches the inner and outer loops.  For example, given a
-loop like:
-@smallexample
-DO J = 1, M
-  DO I = 1, N
-    A(J, I) = A(J, I) * C
-  ENDDO
-ENDDO
-@end smallexample
-@noindent
-loop interchange transforms the loop as if it were written:
-@smallexample
-DO I = 1, N
-  DO J = 1, M
-    A(J, I) = A(J, I) * C
-  ENDDO
-ENDDO
-@end smallexample
-which can be beneficial when @code{N} is larger than the caches,
-because in Fortran, the elements of an array are stored in memory
-contiguously by column, and the original loop iterates over rows,
-potentially creating at each access a cache miss.  This optimization
-applies to all the languages supported by GCC and is not limited to
-Fortran.  To use this code transformation, GCC has to be configured
-with @option{--with-isl} to enable the Graphite loop transformation
-infrastructure.
-
-@item -floop-strip-mine
 @opindex floop-strip-mine
-Perform loop strip mining transformations on loops.  Strip mining
-splits a loop into two nested loops.  The outer loop has strides
-equal to the strip size and the inner loop has strides of the
-original loop within a strip.  The strip length can be changed
-using the @option{loop-block-tile-size} parameter.  For example,
-given a loop like:
-@smallexample
-DO I = 1, N
-  A(I) = A(I) + C
-ENDDO
-@end smallexample
-@noindent
-loop strip mining transforms the loop as if it were written:
-@smallexample
-DO II = 1, N, 51
-  DO I = II, min (II + 50, N)
-    A(I) = A(I) + C
-  ENDDO
-ENDDO
-@end smallexample
-This optimization applies to all the languages supported by GCC and is
-not limited to Fortran.  To use this code transformation, GCC has to
-be configured with @option{--with-isl} to enable the Graphite loop
-transformation infrastructure.
-
-@item -floop-block
 @opindex floop-block
-Perform loop blocking transformations on loops.  Blocking strip mines
-each loop in the loop nest such that the memory accesses of the
-element loops fit inside caches.  The strip length can be changed
-using the @option{loop-block-tile-size} parameter.  For example, given
-a loop like:
-@smallexample
-DO I = 1, N
-  DO J = 1, M
-    A(J, I) = B(I) + C(J)
-  ENDDO
-ENDDO
-@end smallexample
-@noindent
-loop blocking transforms the loop as if it were written:
-@smallexample
-DO II = 1, N, 51
-  DO JJ = 1, M, 51
-    DO I = II, min (II + 50, N)
-      DO J = JJ, min (JJ + 50, M)
-        A(J, I) = B(I) + C(J)
-      ENDDO
-    ENDDO
-  ENDDO
-ENDDO
-@end smallexample
-which can be beneficial when @code{M} is larger than the caches,
-because the innermost loop iterates over a smaller amount of data
-which can be kept in the caches.  This optimization applies to all the
-languages supported by GCC and is not limited to Fortran.  To use this
-code transformation, GCC has to be configured with @option{--with-isl}
-to enable the Graphite loop transformation infrastructure.
+@opindex floop-unroll-and-jam
+Perform loop nest optimizations.  Same as
+@option{-floop-nest-optimize}.  To use this code transformation, GCC has
+to be configured with @option{--with-isl} to enable the Graphite loop
+transformation infrastructure.
 
 @item -fgraphite-identity
 @opindex fgraphite-identity
@@ -8722,13 +8639,6 @@ optimizer based on the Pluto optimization algorithms.  It calculates a loop
 structure optimized for data-locality and parallelism.  This option
 is experimental.
 
-@item -floop-unroll-and-jam
-@opindex floop-unroll-and-jam
-Perform loop nest transformations.  Same as
-@option{-floop-nest-optimize}.  To use this code transformation, GCC has
-to be configured with @option{--with-isl} to enable the Graphite loop
-transformation infrastructure.
-
 @item -floop-parallelize-all
 @opindex floop-parallelize-all
 Use the Graphite data dependence analysis to identify loops that can
diff --git a/gcc/graphite-optimize-isl.c b/gcc/graphite-optimize-isl.c
index 1565996a980..77391a4cb44 100644
--- a/gcc/graphite-optimize-isl.c
+++ b/gcc/graphite-optimize-isl.c
@@ -200,12 +200,21 @@ getScheduleForBand (isl_band *Band, int *Dimensions)
 
   /* It does not make any sense to tile a band with just one dimension.  */
   if (*Dimensions == 1)
-    return PartialSchedule;
+    {
+      if (dump_file && dump_flags)
+	fprintf (dump_file, "not tiled\n");
+      return PartialSchedule;
+    }
+
+  if (dump_file && dump_flags)
+    fprintf (dump_file, "tiled by %d\n",
+	     PARAM_VALUE (PARAM_LOOP_BLOCK_TILE_SIZE));
 
   ctx = isl_union_map_get_ctx (PartialSchedule);
   Space = isl_union_map_get_space (PartialSchedule);
 
-  TileMap = getTileMap (ctx, *Dimensions, 32);
+  TileMap = getTileMap (ctx, *Dimensions,
+			PARAM_VALUE (PARAM_LOOP_BLOCK_TILE_SIZE));
   TileUMap = isl_union_map_from_map (isl_map_from_basic_map (TileMap));
   TileUMap = isl_union_map_align_params (TileUMap, Space);
   *Dimensions = 2 * *Dimensions;
diff --git a/gcc/graphite-poly.c b/gcc/graphite-poly.c
index 8bd43a608a0..28d446a4f0e 100644
--- a/gcc/graphite-poly.c
+++ b/gcc/graphite-poly.c
@@ -93,94 +93,6 @@ debug_gmp_value (mpz_t val)
   gmp_fprintf (stderr, "%Zd", val);
 }
 
-/* Return the maximal loop depth in SCOP.  */
-
-int
-scop_max_loop_depth (scop_p scop)
-{
-  int i;
-  poly_bb_p pbb;
-  int max_nb_loops = 0;
-
-  FOR_EACH_VEC_ELT (SCOP_BBS (scop), i, pbb)
-    {
-      int nb_loops = pbb_dim_iter_domain (pbb);
-      if (max_nb_loops < nb_loops)
-        max_nb_loops = nb_loops;
-    }
-
-  return max_nb_loops;
-}
-
-/* Prints to FILE the scattering function of PBB, at some VERBOSITY
-   level.  */
-
-static void
-print_scattering_function_1 (FILE *file, poly_bb_p pbb, int verbosity)
-{
-  graphite_dim_t i;
-
-  if (verbosity > 0)
-    {
-      fprintf (file, "# scattering bb_%d (\n", pbb_index (pbb));
-      fprintf (file, "#eq");
-
-      for (i = 0; i < pbb_nb_scattering_transform (pbb); i++)
-	fprintf (file, "     s%d", (int) i);
-
-      for (i = 0; i < pbb_nb_local_vars (pbb); i++)
-	fprintf (file, "    lv%d", (int) i);
-
-      for (i = 0; i < pbb_dim_iter_domain (pbb); i++)
-	fprintf (file, "     i%d", (int) i);
-
-      for (i = 0; i < pbb_nb_params (pbb); i++)
-	fprintf (file, "     p%d", (int) i);
-
-      fprintf (file, "    cst\n");
-    }
-
-  fprintf (file, "isl\n");
-  print_isl_map (file, pbb->transformed ? pbb->transformed : pbb->schedule);
-
-  if (verbosity > 0)
-    fprintf (file, "#)\n");
-}
-
-/* Prints to FILE the scattering function of PBB, at some VERBOSITY
-   level.  */
-
-void
-print_scattering_function (FILE *file, poly_bb_p pbb, int verbosity)
-{
-  if (!PBB_TRANSFORMED (pbb))
-    return;
-
-  if (pbb->schedule || pbb->transformed)
-    {
-      if (verbosity > 0)
-	fprintf (file, "# Scattering function is provided\n");
-
-      fprintf (file, "1\n");
-    }
-  else
-    {
-      if (verbosity > 0)
-	fprintf (file, "# Scattering function is not provided\n");
-
-      fprintf (file, "0\n");
-      return;
-    }
-
-  print_scattering_function_1 (file, pbb, verbosity);
-
-  if (verbosity > 0)
-    fprintf (file, "# Scattering names are not provided\n");
-
-  fprintf (file, "0\n");
-
-}
-
 /* Prints to FILE the iteration domain of PBB, at some VERBOSITY
    level.  */
 
@@ -190,18 +102,6 @@ print_iteration_domain (FILE *file, poly_bb_p pbb, int verbosity)
   print_pbb_domain (file, pbb, verbosity);
 }
 
-/* Prints to FILE the scattering functions of every PBB of SCOP.  */
-
-void
-print_scattering_functions (FILE *file, scop_p scop, int verbosity)
-{
-  int i;
-  poly_bb_p pbb;
-
-  FOR_EACH_VEC_ELT (SCOP_BBS (scop), i, pbb)
-    print_scattering_function (file, pbb, verbosity);
-}
-
 /* Prints to FILE the iteration domains of every PBB of SCOP, at some
    VERBOSITY level.  */
 
@@ -215,15 +115,6 @@ print_iteration_domains (FILE *file, scop_p scop, int verbosity)
     print_iteration_domain (file, pbb, verbosity);
 }
 
-/* Prints to STDERR the scattering function of PBB, at some VERBOSITY
-   level.  */
-
-DEBUG_FUNCTION void
-debug_scattering_function (poly_bb_p pbb, int verbosity)
-{
-  print_scattering_function (stderr, pbb, verbosity);
-}
-
 /* Prints to STDERR the iteration domain of PBB, at some VERBOSITY
    level.  */
 
@@ -233,15 +124,6 @@ debug_iteration_domain (poly_bb_p pbb, int verbosity)
   print_iteration_domain (stderr, pbb, verbosity);
 }
 
-/* Prints to STDERR the scattering functions of every PBB of SCOP, at
-   some VERBOSITY level.  */
-
-DEBUG_FUNCTION void
-debug_scattering_functions (scop_p scop, int verbosity)
-{
-  print_scattering_functions (stderr, scop, verbosity);
-}
-
 /* Prints to STDERR the iteration domains of every PBB of SCOP, at
    some VERBOSITY level.  */
 
@@ -260,28 +142,13 @@ apply_poly_transforms (scop_p scop)
 
   /* Generate code even if we did not apply any real transformation.
      This also allows to check the performance for the identity
-     transformation: GIMPLE -> GRAPHITE -> GIMPLE
-     Keep in mind that CLooG optimizes in control, so the loop structure
-     may change, even if we only use -fgraphite-identity.  */
+     transformation: GIMPLE -> GRAPHITE -> GIMPLE.  */
   if (flag_graphite_identity)
     transform_done = true;
 
   if (flag_loop_parallelize_all)
     transform_done = true;
 
-  if (flag_loop_block)
-    transform_done |= scop_do_block (scop);
-  else
-    {
-      if (flag_loop_strip_mine)
-	transform_done |= scop_do_strip_mine (scop, 0);
-
-      if (flag_loop_interchange)
-	transform_done |= scop_do_interchange (scop);
-    }
-
-  /* This pass needs to be run at the final stage, as it does not
-     update the lst.  */
   if (flag_loop_optimize_isl)
     transform_done |= optimize_isl (scop);
 
@@ -335,9 +202,6 @@ new_poly_bb (scop_p scop, void *black_box)
   pbb->saved = NULL;
   PBB_SCOP (pbb) = scop;
   pbb_set_black_box (pbb, black_box);
-  PBB_TRANSFORMED (pbb) = NULL;
-  PBB_SAVED (pbb) = NULL;
-  PBB_ORIGINAL (pbb) = NULL;
   PBB_DRS (pbb).create (3);
   PBB_IS_REDUCTION (pbb) = false;
   GBB_PBB ((gimple_bb_p) black_box) = pbb;
@@ -366,27 +230,6 @@ free_poly_bb (poly_bb_p pbb)
   XDELETE (pbb);
 }
 
-static void
-print_pdr_access_layout (FILE *file, poly_bb_p pbb, poly_dr_p pdr)
-{
-  graphite_dim_t i;
-
-  fprintf (file, "#  eq");
-
-  fprintf (file, "   alias");
-
-  for (i = 0; i < PDR_NB_SUBSCRIPTS (pdr); i++)
-    fprintf (file, "   sub%d", (int) i);
-
-  for (i = 0; i < pbb_dim_iter_domain (pbb); i++)
-    fprintf (file, "     i%d", (int) i);
-
-  for (i = 0; i < pbb_nb_params (pbb); i++)
-    fprintf (file, "     p%d", (int) i);
-
-  fprintf (file, "    cst\n");
-}
-
 /* Prints to FILE the polyhedral data reference PDR, at some VERBOSITY
    level.  */
 
@@ -421,14 +264,10 @@ print_pdr (FILE *file, poly_dr_p pdr, int verbosity)
   if (verbosity > 0)
     {
       fprintf (file, "# data accesses (\n");
-      print_pdr_access_layout (file, PDR_PBB (pdr), pdr);
+      print_isl_map (file, pdr->accesses);
+      print_isl_set (file, pdr->subscript_sizes);
+      fprintf (file, "#)\n");
     }
-
-  /* XXX isl dump accesses/subscripts */
-
-  if (verbosity > 0)
-    fprintf (file, "#)\n");
-
   if (verbosity > 1)
     fprintf (file, "#)\n");
 }
@@ -464,9 +303,6 @@ new_scop (void *region)
   scop->may_waw_no_source = NULL;
   scop_set_region (scop, region);
   SCOP_BBS (scop).create (3);
-  SCOP_ORIGINAL_SCHEDULE (scop) = NULL;
-  SCOP_TRANSFORMED_SCHEDULE (scop) = NULL;
-  SCOP_SAVED_SCHEDULE (scop) = NULL;
   POLY_SCOP_P (scop) = false;
 
   return scop;
@@ -498,44 +334,9 @@ free_scop (scop_p scop)
   isl_union_map_free (scop->may_waw);
   isl_union_map_free (scop->must_waw_no_source);
   isl_union_map_free (scop->may_waw_no_source);
-  free_lst (SCOP_ORIGINAL_SCHEDULE (scop));
-  free_lst (SCOP_TRANSFORMED_SCHEDULE (scop));
-  free_lst (SCOP_SAVED_SCHEDULE (scop));
   XDELETE (scop);
 }
 
-/* Print to FILE the domain of PBB in OpenScop format, at some VERBOSITY
-   level.  */
-
-static void
-openscop_print_pbb_domain (FILE *file, poly_bb_p pbb, int verbosity)
-{
-  graphite_dim_t i;
-  gimple_bb_p gbb = PBB_BLACK_BOX (pbb);
-
-  if (!pbb->domain)
-    return;
-
-  if (verbosity > 0)
-    {
-      fprintf (file, "\n# Iteration domain of bb_%d (\n", GBB_BB (gbb)->index);
-      fprintf (file, "#eq");
-
-      for (i = 0; i < pbb_dim_iter_domain (pbb); i++)
-	fprintf (file, "     i%d", (int) i);
-
-      for (i = 0; i < pbb_nb_params (pbb); i++)
-	fprintf (file, "     p%d", (int) i);
-
-      fprintf (file, "    cst\n");
-    }
-
-  fprintf (file, "XXX isl\n");
-
-  if (verbosity > 0)
-    fprintf (file, "#)\n");
-}
-
 /* Print to FILE the domain of PBB, at some VERBOSITY level.  */
 
 void
@@ -723,8 +524,7 @@ print_pbb (FILE *file, poly_bb_p pbb, int verbosity)
       dump_gbb_cases (file, PBB_BLACK_BOX (pbb));
     }
 
-  openscop_print_pbb_domain (file, pbb, verbosity);
-  print_scattering_function (file, pbb, verbosity);
+  print_pbb_domain (file, pbb, verbosity);
   print_pdrs (file, pbb, verbosity);
   print_pbb_body (file, pbb, verbosity, false);
 
@@ -772,58 +572,16 @@ print_scop_params (FILE *file, scop_p scop, int verbosity)
     fprintf (file, "#)\n");
 }
 
-/* Print to FILE the context of SCoP in OpenScop format, at some VERBOSITY
-   level.  */
-
-static void
-openscop_print_scop_context (FILE *file, scop_p scop, int verbosity)
-{
-  graphite_dim_t i;
-
-  if (verbosity > 0)
-    {
-      fprintf (file, "# Context (\n");
-      fprintf (file, "#eq");
-
-      for (i = 0; i < scop_nb_params (scop); i++)
-	fprintf (file, "     p%d", (int) i);
-
-      fprintf (file, "    cst\n");
-    }
-
-  if (scop->context)
-    /* XXX isl print context */
-    fprintf (file, "XXX isl\n");
-  else
-    fprintf (file, "0 %d 0 0 0 %d\n", (int) scop_nb_params (scop) + 2,
-	     (int) scop_nb_params (scop));
-
-  if (verbosity > 0)
-    fprintf (file, "# )\n");
-}
-
 /* Print to FILE the context of SCoP, at some VERBOSITY level.  */
 
 void
 print_scop_context (FILE *file, scop_p scop, int verbosity)
 {
-  graphite_dim_t i;
-
   if (verbosity > 0)
-    {
-      fprintf (file, "# Context (\n");
-      fprintf (file, "#eq");
-
-      for (i = 0; i < scop_nb_params (scop); i++)
-	fprintf (file, "     p%d", (int) i);
-
-      fprintf (file, "    cst\n");
-    }
+    fprintf (file, "# Context (\n");
 
   if (scop->context)
     print_isl_set (file, scop->context);
-  else
-    fprintf (file, "no isl context %d\n", (int) scop_nb_params (scop) + 2);
 
   if (verbosity > 0)
     fprintf (file, "# )\n");
@@ -839,7 +597,7 @@ print_scop (FILE *file, scop_p scop, int verbosity)
 
   fprintf (file, "SCoP 1\n#(\n");
   fprintf (file, "# Language\nGimple\n");
-  openscop_print_scop_context (file, scop, verbosity);
+  print_scop_context (file, scop, verbosity);
   print_scop_params (file, scop, verbosity);
 
   if (verbosity > 0)
@@ -850,17 +608,6 @@ print_scop (FILE *file, scop_p scop, int verbosity)
   FOR_EACH_VEC_ELT (SCOP_BBS (scop), i, pbb)
     print_pbb (file, pbb, verbosity);
 
-  if (verbosity > 1)
-    {
-      fprintf (file, "# original_lst (\n");
-      print_lst (file, SCOP_ORIGINAL_SCHEDULE (scop), 0);
-      fprintf (file, "\n#)\n");
-
-      fprintf (file, "# transformed_lst (\n");
-      print_lst (file, SCOP_TRANSFORMED_SCHEDULE (scop), 0);
-      fprintf (file, "\n#)\n");
-    }
-
   fprintf (file, "#)\n");
 }
 
@@ -912,6 +659,7 @@ print_isl_set (FILE *f, isl_set *set)
 {
   isl_printer *p = isl_printer_to_file (the_isl_ctx, f);
   p = isl_printer_print_set (p, set);
+  p = isl_printer_print_str (p, "\n");
   isl_printer_free (p);
 }
 
@@ -926,6 +674,7 @@ print_isl_map (FILE *f, isl_map *map)
 {
   isl_printer *p = isl_printer_to_file (the_isl_ctx, f);
   p = isl_printer_print_map (p, map);
+  p = isl_printer_print_str (p, "\n");
   isl_printer_free (p);
 }
 
@@ -940,6 +689,7 @@ print_isl_aff (FILE *f, isl_aff *aff)
 {
   isl_printer *p = isl_printer_to_file (the_isl_ctx, f);
   p = isl_printer_print_aff (p, aff);
+  p = isl_printer_print_str (p, "\n");
   isl_printer_free (p);
 }
 
@@ -954,6 +704,7 @@ print_isl_constraint (FILE *f, isl_constraint *c)
 {
   isl_printer *p = isl_printer_to_file (the_isl_ctx, f);
   p = isl_printer_print_constraint (p, c);
+  p = isl_printer_print_str (p, "\n");
   isl_printer_free (p);
 }
 
@@ -1000,224 +751,5 @@ pbb_number_of_iterations_at_time (poly_bb_p pbb,
   isl_set_free (transdomain);
 }
 
-/* Translates LOOP to LST.  */
-
-static lst_p
-loop_to_lst (loop_p loop, vec<poly_bb_p> bbs, int *i)
-{
-  poly_bb_p pbb;
-  vec<lst_p> seq;
-  seq.create (5);
-
-  for (; bbs.iterate (*i, &pbb); (*i)++)
-    {
-      lst_p stmt;
-      basic_block bb = GBB_BB (PBB_BLACK_BOX (pbb));
-
-      if (bb->loop_father == loop)
-	stmt = new_lst_stmt (pbb);
-      else if (flow_bb_inside_loop_p (loop, bb))
-	{
-	  loop_p next = loop->inner;
-
-	  while (next && !flow_bb_inside_loop_p (next, bb))
-	    next = next->next;
-
-	  stmt = loop_to_lst (next, bbs, i);
-	}
-      else
-	{
-	  (*i)--;
-	  return new_lst_loop (seq);
-	}
-
-      seq.safe_push (stmt);
-    }
-
-  return new_lst_loop (seq);
-}
-
-/* Reads the original scattering of the SCOP and returns an LST
-   representing it.  */
-
-void
-scop_to_lst (scop_p scop)
-{
-  lst_p res;
-  int i, n = SCOP_BBS (scop).length ();
-  vec<lst_p> seq;
-  seq.create (5);
-  sese region = SCOP_REGION (scop);
-
-  for (i = 0; i < n; i++)
-    {
-      poly_bb_p pbb = SCOP_BBS (scop)[i];
-      loop_p loop = outermost_loop_in_sese (region, GBB_BB (PBB_BLACK_BOX (pbb)));
-
-      if (loop_in_sese_p (loop, region))
-	res = loop_to_lst (loop, SCOP_BBS (scop), &i);
-      else
-	res = new_lst_stmt (pbb);
-
-      seq.safe_push (res);
-    }
-
-  res = new_lst_loop (seq);
-  SCOP_ORIGINAL_SCHEDULE (scop) = res;
-  SCOP_TRANSFORMED_SCHEDULE (scop) = copy_lst (res);
-}
-
-/* Print to FILE on a new line COLUMN white spaces.  */
-
-static void
-lst_indent_to (FILE *file, int column)
-{
-  int i;
-
-  if (column > 0)
-    fprintf (file, "\n#");
-
-  for (i = 0; i < column; i++)
-    fprintf (file, " ");
-}
-
-/* Print LST to FILE with INDENT spaces of indentation.  */
-
-void
-print_lst (FILE *file, lst_p lst, int indent)
-{
-  if (!lst)
-    return;
-
-  lst_indent_to (file, indent);
-
-  if (LST_LOOP_P (lst))
-    {
-      int i;
-      lst_p l;
-
-      if (LST_LOOP_FATHER (lst))
-	fprintf (file, "%d (loop", lst_dewey_number (lst));
-      else
-	fprintf (file, "#(root");
-
-      FOR_EACH_VEC_ELT (LST_SEQ (lst), i, l)
-	print_lst (file, l, indent + 2);
-
-      fprintf (file, ")");
-    }
-  else
-    fprintf (file, "%d stmt_%d", lst_dewey_number (lst), pbb_index (LST_PBB (lst)));
-}
-
-/* Print LST to STDERR.  */
-
-DEBUG_FUNCTION void
-debug_lst (lst_p lst)
-{
-  print_lst (stderr, lst, 0);
-}
-
-/* Pretty print to FILE the loop statement tree LST in DOT format.  */
-
-static void
-dot_lst_1 (FILE *file, lst_p lst)
-{
-  if (!lst)
-    return;
-
-  if (LST_LOOP_P (lst))
-    {
-      int i;
-      lst_p l;
-
-      if (!LST_LOOP_FATHER (lst))
-	fprintf (file, "L -> L_%d_%d\n",
-		 lst_depth (lst),
-		 lst_dewey_number (lst));
-      else
-	fprintf (file, "L_%d_%d -> L_%d_%d\n",
-		 lst_depth (LST_LOOP_FATHER (lst)),
-		 lst_dewey_number (LST_LOOP_FATHER (lst)),
-		 lst_depth (lst),
-		 lst_dewey_number (lst));
-
-      FOR_EACH_VEC_ELT (LST_SEQ (lst), i, l)
-	dot_lst_1 (file, l);
-    }
-
-  else
-    fprintf (file, "L_%d_%d -> S_%d\n",
-	     lst_depth (LST_LOOP_FATHER (lst)),
-	     lst_dewey_number (LST_LOOP_FATHER (lst)),
-	     pbb_index (LST_PBB (lst)));
-
-}
-
-/* Display the LST using dotty.  */
-
-DEBUG_FUNCTION void
-dot_lst (lst_p lst)
-{
-  /* When debugging, enable the following code.  This cannot be used
-     in production compilers because it calls "system".  */
-#if 0
-  FILE *stream = fopen ("/tmp/lst.dot", "w");
-  gcc_assert (stream);
-
-  fputs ("digraph all {\n", stream);
-  dot_lst_1 (stream, lst);
-  fputs ("}\n\n", stream);
-  fclose (stream);
-
-  system ("dotty /tmp/lst.dot &");
-#else
-  fputs ("digraph all {\n", stderr);
-  dot_lst_1 (stderr, lst);
-  fputs ("}\n\n", stderr);
-
-#endif
-}
-
-/* Reverse the loop around PBB at level DEPTH.  */
-
-isl_map *
-reverse_loop_at_level (poly_bb_p pbb, int depth)
-{
-  unsigned i, depth_dim = psct_dynamic_dim (pbb, depth);
-  isl_space *d = isl_map_get_space (pbb->transformed);
-  isl_space *d1 = isl_space_range (d);
-  unsigned n = isl_space_dim (d1, isl_dim_out);
-  isl_space *d2 = isl_space_add_dims (d1, isl_dim_in, n);
-  isl_map *x = isl_map_universe (isl_space_copy (d2));
-  isl_constraint *c = isl_equality_alloc (isl_local_space_from_space (d2));
-
-  for (i = 0; i < n; i++)
-    if (i != depth_dim)
-      x = isl_map_equate (x, isl_dim_in, i, isl_dim_out, i);
-
-  c = isl_constraint_set_coefficient_si (c, isl_dim_in, depth_dim, 1);
-  c = isl_constraint_set_coefficient_si (c, isl_dim_out, depth_dim, 1);
-  x = isl_map_add_constraint (x, c);
-  return x;
-}
-
-/* Reverse the loop at level DEPTH for all the PBBS.  */
-
-isl_union_map *
-reverse_loop_for_pbbs (scop_p scop, vec<poly_bb_p> pbbs, int depth)
-{
-  poly_bb_p pbb;
-  int i;
-  isl_space *space = isl_space_from_domain (isl_set_get_space (scop->context));
-  isl_union_map *res = isl_union_map_empty (space);
-
-  for (i = 0; pbbs.iterate (i, &pbb); i++)
-    res = isl_union_map_add_map (res, reverse_loop_at_level (pbb, depth));
-
-  return res;
-}
-
-
 #endif
 
diff --git a/gcc/graphite-poly.h b/gcc/graphite-poly.h
index bad6154befb..49555b7a9d1 100644
--- a/gcc/graphite-poly.h
+++ b/gcc/graphite-poly.h
@@ -35,8 +35,6 @@ typedef struct scop *scop_p;
 
 typedef unsigned graphite_dim_t;
 
-static inline graphite_dim_t pbb_dim_iter_domain (const struct poly_bb *);
-static inline graphite_dim_t pbb_nb_params (const struct poly_bb *);
 static inline graphite_dim_t scop_nb_params (scop_p);
 
 /* A data reference can write or read some memory or we
@@ -204,63 +202,6 @@ void new_poly_dr (poly_bb_p, int, enum poly_dr_type, void *,
 void free_poly_dr (poly_dr_p);
 void debug_pdr (poly_dr_p, int);
 void print_pdr (FILE *, poly_dr_p, int);
-static inline scop_p pdr_scop (poly_dr_p pdr);
-
-/* The dimension of the iteration domain of the scop of PDR.  */
-
-static inline graphite_dim_t
-pdr_dim_iter_domain (poly_dr_p pdr)
-{
-  return pbb_dim_iter_domain (PDR_PBB (pdr));
-}
-
-/* The number of parameters of the scop of PDR.  */
-
-static inline graphite_dim_t
-pdr_nb_params (poly_dr_p pdr)
-{
-  return scop_nb_params (pdr_scop (pdr));
-}
-
-/* The dimension of the alias set in PDR.  */
-
-static inline graphite_dim_t
-pdr_alias_set_dim (poly_dr_p pdr)
-{
-  poly_bb_p pbb = PDR_PBB (pdr);
-
-  return pbb_dim_iter_domain (pbb) + pbb_nb_params (pbb);
-}
-
-/* The dimension in PDR containing subscript S.  */
-
-static inline graphite_dim_t
-pdr_subscript_dim (poly_dr_p pdr, graphite_dim_t s)
-{
-  poly_bb_p pbb = PDR_PBB (pdr);
-
-  return pbb_dim_iter_domain (pbb) + pbb_nb_params (pbb) + 1 + s;
-}
-
-/* The dimension in PDR containing the loop iterator ITER.  */
-
-static inline graphite_dim_t
-pdr_iterator_dim (poly_dr_p pdr ATTRIBUTE_UNUSED, graphite_dim_t iter)
-{
-  return iter;
-}
-
-/* The dimension in PDR containing parameter PARAM.  */
-
-static inline graphite_dim_t
-pdr_parameter_dim (poly_dr_p pdr, graphite_dim_t param)
-{
-  poly_bb_p pbb = PDR_PBB (pdr);
-
-  return pbb_dim_iter_domain (pbb) + param;
-}
-
-/* Returns true when PDR is a "read".  */
 
 static inline bool
 pdr_read_p (poly_dr_p pdr)
@@ -284,27 +225,6 @@ pdr_may_write_p (poly_dr_p pdr)
   return PDR_TYPE (pdr) == PDR_MAY_WRITE;
 }
 
-/* Return true when PDR1 and PDR2 are similar data accesses: they have
-   the same base array, and the same access functions.  */
-
-static inline bool
-same_pdr_p (poly_dr_p pdr1, poly_dr_p pdr2)
-{
-  return PDR_NB_SUBSCRIPTS (pdr1) == PDR_NB_SUBSCRIPTS (pdr2)
-    && PDR_BASE_OBJECT_SET (pdr1) == PDR_BASE_OBJECT_SET (pdr2);
-}
-
-typedef struct poly_scattering *poly_scattering_p;
-
-struct poly_scattering
-{
-  /* The number of local variables.  */
-  int nb_local_variables;
-
-  /* The number of scattering dimensions.  */
-  int nb_scattering;
-};
-
 /* POLY_BB represents a blackbox in the polyhedral model.  */
 
 struct poly_bb
@@ -343,15 +263,12 @@ struct poly_bb
   vec<poly_dr_p> drs;
 
   /* The original scattering.  */
-  poly_scattering_p _original;
   isl_map *schedule;
 
   /* The transformed scattering.  */
-  poly_scattering_p _transformed;
   isl_map *transformed;
 
   /* A copy of the transformed scattering.  */
-  poly_scattering_p _saved;
   isl_map *saved;
 
   /* True when this PBB contains only a reduction statement.  */
@@ -360,24 +277,12 @@ struct poly_bb
 
 #define PBB_BLACK_BOX(PBB) ((gimple_bb_p) PBB->black_box)
 #define PBB_SCOP(PBB) (PBB->scop)
-#define PBB_DOMAIN(PBB) (NULL)
 #define PBB_DRS(PBB) (PBB->drs)
-#define PBB_ORIGINAL(PBB) (PBB->_original)
-#define PBB_ORIGINAL_SCATTERING(PBB) (NULL)
-#define PBB_TRANSFORMED(PBB) (PBB->_transformed)
-#define PBB_TRANSFORMED_SCATTERING(PBB) (NULL)
-#define PBB_SAVED(PBB) (PBB->_saved)
-/* XXX isl if we ever need local vars in the scatter, we can't use the
-   out dimension of transformed to count the scatterting transform dimension.
-   */
-#define PBB_NB_LOCAL_VARIABLES(PBB) (0)
-#define PBB_NB_SCATTERING_TRANSFORM(PBB) (isl_map_n_out (PBB->transformed))
 #define PBB_IS_REDUCTION(PBB) (PBB->is_reduction)
 
 extern poly_bb_p new_poly_bb (scop_p, void *);
 extern void free_poly_bb (poly_bb_p);
 extern void debug_loop_vec (poly_bb_p);
-extern void schedule_to_scattering (poly_bb_p, int);
 extern void print_pbb_domain (FILE *, poly_bb_p, int);
 extern void print_pbb (FILE *, poly_bb_p, int);
 extern void print_scop_context (FILE *, scop_p, int);
@@ -410,22 +315,6 @@ extern bool optimize_isl (scop_p);
 extern void pbb_number_of_iterations_at_time (poly_bb_p, graphite_dim_t, mpz_t);
 extern void debug_gmp_value (mpz_t);
 
-/* Return the number of write data references in PBB.  */
-
-static inline int
-number_of_write_pdrs (poly_bb_p pbb)
-{
-  int res = 0;
-  int i;
-  poly_dr_p pdr;
-
-  for (i = 0; PBB_DRS (pbb).iterate (i, &pdr); i++)
-    if (PDR_TYPE (pdr) == PDR_WRITE)
-      res++;
-
-  return res;
-}
-
 /* Returns a gimple_bb from BB.  */
 
 static inline gimple_bb_p
@@ -450,8 +339,6 @@ pbb_bb (poly_bb_p pbb)
   return GBB_BB (PBB_BLACK_BOX (pbb));
 }
 
-/* The index of the PBB.  */
-
 static inline int
 pbb_index (poly_bb_p pbb)
 {
@@ -482,859 +369,6 @@ pbb_set_black_box (poly_bb_p pbb, void *black_box)
   pbb->black_box = black_box;
 }
 
-/* The number of loops around PBB: the dimension of the iteration
-   domain.  */
-
-static inline graphite_dim_t
-pbb_dim_iter_domain (const struct poly_bb *pbb)
-{
-  return isl_set_dim (pbb->domain, isl_dim_set);
-}
-
-/* The number of params defined in PBB.  */
-
-static inline graphite_dim_t
-pbb_nb_params (const struct poly_bb *pbb)
-{
-  scop_p scop = PBB_SCOP (pbb);
-
-  return scop_nb_params (scop);
-}
-
-/* The number of scattering dimensions in the SCATTERING polyhedron
-   of a PBB for a given SCOP.  */
-
-static inline graphite_dim_t
-pbb_nb_scattering_orig (const struct poly_bb *pbb)
-{
-  return 2 * pbb_dim_iter_domain (pbb) + 1;
-}
-
-/* The number of scattering dimensions in PBB.  */
-
-static inline graphite_dim_t
-pbb_nb_scattering_transform (const struct poly_bb *pbb)
-{
-  return PBB_NB_SCATTERING_TRANSFORM (pbb);
-}
-
-/* The number of dynamic scattering dimensions in PBB.  */
-
-static inline graphite_dim_t
-pbb_nb_dynamic_scattering_transform (const struct poly_bb *pbb)
-{
-  /* This function requires the 2d + 1 scattering format to be
-     invariant during all transformations.  */
-  gcc_assert (PBB_NB_SCATTERING_TRANSFORM (pbb) % 2);
-  return PBB_NB_SCATTERING_TRANSFORM (pbb) / 2;
-}
-
-/* Returns the number of local variables used in the transformed
-   scattering polyhedron of PBB.  */
-
-static inline graphite_dim_t
-pbb_nb_local_vars (const struct poly_bb *pbb ATTRIBUTE_UNUSED)
-{
-  /* For now we do not have any local variables, as we do not do strip
-     mining for example.  */
-  return PBB_NB_LOCAL_VARIABLES (pbb);
-}
-
-/* The dimension in the domain of PBB containing the iterator ITER.  */
-
-static inline graphite_dim_t
-pbb_iterator_dim (poly_bb_p pbb ATTRIBUTE_UNUSED, graphite_dim_t iter)
-{
-  return iter;
-}
-
-/* The dimension in the domain of PBB containing the iterator ITER.  */
-
-static inline graphite_dim_t
-pbb_parameter_dim (poly_bb_p pbb, graphite_dim_t param)
-{
-  return param
-    + pbb_dim_iter_domain (pbb);
-}
-
-/* The dimension in the original scattering polyhedron of PBB
-   containing the scattering iterator SCATTER.  */
-
-static inline graphite_dim_t
-psco_scattering_dim (poly_bb_p pbb ATTRIBUTE_UNUSED, graphite_dim_t scatter)
-{
-  gcc_assert (scatter < pbb_nb_scattering_orig (pbb));
-  return scatter;
-}
-
-/* The dimension in the transformed scattering polyhedron of PBB
-   containing the scattering iterator SCATTER.  */
-
-static inline graphite_dim_t
-psct_scattering_dim (poly_bb_p pbb ATTRIBUTE_UNUSED, graphite_dim_t scatter)
-{
-  gcc_assert (scatter <= pbb_nb_scattering_transform (pbb));
-  return scatter;
-}
-
-/* The dimension in the transformed scattering polyhedron of PBB of
-   the local variable LV.  */
-
-static inline graphite_dim_t
-psct_local_var_dim (poly_bb_p pbb, graphite_dim_t lv)
-{
-  gcc_assert (lv <= pbb_nb_local_vars (pbb));
-  return lv + pbb_nb_scattering_transform (pbb);
-}
-
-/* The dimension in the original scattering polyhedron of PBB
-   containing the loop iterator ITER.  */
-
-static inline graphite_dim_t
-psco_iterator_dim (poly_bb_p pbb, graphite_dim_t iter)
-{
-  gcc_assert (iter < pbb_dim_iter_domain (pbb));
-  return iter + pbb_nb_scattering_orig (pbb);
-}
-
-/* The dimension in the transformed scattering polyhedron of PBB
-   containing the loop iterator ITER.  */
-
-static inline graphite_dim_t
-psct_iterator_dim (poly_bb_p pbb, graphite_dim_t iter)
-{
-  gcc_assert (iter < pbb_dim_iter_domain (pbb));
-  return iter
-    + pbb_nb_scattering_transform (pbb)
-    + pbb_nb_local_vars (pbb);
-}
-
-/* The dimension in the original scattering polyhedron of PBB
-   containing parameter PARAM.  */
-
-static inline graphite_dim_t
-psco_parameter_dim (poly_bb_p pbb, graphite_dim_t param)
-{
-  gcc_assert (param < pbb_nb_params (pbb));
-  return param
-    + pbb_nb_scattering_orig (pbb)
-    + pbb_dim_iter_domain (pbb);
-}
-
-/* The dimension in the transformed scattering polyhedron of PBB
-   containing parameter PARAM.  */
-
-static inline graphite_dim_t
-psct_parameter_dim (poly_bb_p pbb, graphite_dim_t param)
-{
-  gcc_assert (param < pbb_nb_params (pbb));
-  return param
-    + pbb_nb_scattering_transform (pbb)
-    + pbb_nb_local_vars (pbb)
-    + pbb_dim_iter_domain (pbb);
-}
-
-/* The scattering dimension of PBB corresponding to the dynamic level
-   LEVEL.  */
-
-static inline graphite_dim_t
-psct_dynamic_dim (poly_bb_p pbb, graphite_dim_t level)
-{
-  graphite_dim_t result = 1 + 2 * level;
-
-  gcc_assert (result < pbb_nb_scattering_transform (pbb));
-  return result;
-}
-
-/* The scattering dimension of PBB corresponding to the static
-   sequence of the loop level LEVEL.  */
-
-static inline graphite_dim_t
-psct_static_dim (poly_bb_p pbb, graphite_dim_t level)
-{
-  graphite_dim_t result = 2 * level;
-
-  gcc_assert (result < pbb_nb_scattering_transform (pbb));
-  return result;
-}
-
-/* Adds to the transformed scattering polyhedron of PBB a new local
-   variable and returns its index.  */
-
-static inline graphite_dim_t
-psct_add_local_variable (poly_bb_p pbb ATTRIBUTE_UNUSED)
-{
-  gcc_unreachable ();
-  return 0;
-}
-
-typedef struct lst *lst_p;
-
-/* Loops and Statements Tree.  */
-struct lst {
-
-  /* LOOP_P is true when an LST node is a loop.  */
-  bool loop_p;
-
-  /* A pointer to the loop that contains this node.  */
-  lst_p loop_father;
-
-  /* The sum of all the memory strides for an LST loop.  */
-  mpz_t memory_strides;
-
-  /* Loop nodes contain a sequence SEQ of LST nodes, statements
-     contain a pointer to their polyhedral representation PBB.  */
-  union {
-    poly_bb_p pbb;
-    vec<lst_p> seq;
-  } node;
-};
-
-#define LST_LOOP_P(LST) ((LST)->loop_p)
-#define LST_LOOP_FATHER(LST) ((LST)->loop_father)
-#define LST_PBB(LST) ((LST)->node.pbb)
-#define LST_SEQ(LST) ((LST)->node.seq)
-#define LST_LOOP_MEMORY_STRIDES(LST) ((LST)->memory_strides)
-
-void scop_to_lst (scop_p);
-void print_lst (FILE *, lst_p, int);
-void debug_lst (lst_p);
-void dot_lst (lst_p);
-
-/* Creates a new LST loop with SEQ.  */
-
-static inline lst_p
-new_lst_loop (vec<lst_p> seq)
-{
-  lst_p lst = XNEW (struct lst);
-  int i;
-  lst_p l;
-
-  LST_LOOP_P (lst) = true;
-  LST_SEQ (lst) = seq;
-  LST_LOOP_FATHER (lst) = NULL;
-  mpz_init (LST_LOOP_MEMORY_STRIDES (lst));
-  mpz_set_si (LST_LOOP_MEMORY_STRIDES (lst), -1);
-
-  for (i = 0; seq.iterate (i, &l); i++)
-    LST_LOOP_FATHER (l) = lst;
-
-  return lst;
-}
-
-/* Creates a new LST statement with PBB.  */
-
-static inline lst_p
-new_lst_stmt (poly_bb_p pbb)
-{
-  lst_p lst = XNEW (struct lst);
-
-  LST_LOOP_P (lst) = false;
-  LST_PBB (lst) = pbb;
-  LST_LOOP_FATHER (lst) = NULL;
-  return lst;
-}
-
-/* Frees the memory used by LST.  */
-
-static inline void
-free_lst (lst_p lst)
-{
-  if (!lst)
-    return;
-
-  if (LST_LOOP_P (lst))
-    {
-      int i;
-      lst_p l;
-
-      for (i = 0; LST_SEQ (lst).iterate (i, &l); i++)
-	free_lst (l);
-
-      mpz_clear (LST_LOOP_MEMORY_STRIDES (lst));
-      LST_SEQ (lst).release ();
-    }
-
-  free (lst);
-}
-
-/* Returns a copy of LST.  */
-
-static inline lst_p
-copy_lst (lst_p lst)
-{
-  if (!lst)
-    return NULL;
-
-  if (LST_LOOP_P (lst))
-    {
-      int i;
-      lst_p l;
-      vec<lst_p> seq;
-      seq.create (5);
-
-      for (i = 0; LST_SEQ (lst).iterate (i, &l); i++)
-	seq.safe_push (copy_lst (l));
-
-      return new_lst_loop (seq);
-    }
-
-  return new_lst_stmt (LST_PBB (lst));
-}
-
-/* Adds a new loop under the loop LST.  */
-
-static inline void
-lst_add_loop_under_loop (lst_p lst)
-{
-  vec<lst_p> seq;
-  seq.create (1);
-  lst_p l = new_lst_loop (LST_SEQ (lst));
-
-  gcc_assert (LST_LOOP_P (lst));
-
-  LST_LOOP_FATHER (l) = lst;
-  seq.quick_push (l);
-  LST_SEQ (lst) = seq;
-}
-
-/* Returns the loop depth of LST.  */
-
-static inline int
-lst_depth (lst_p lst)
-{
-  if (!lst)
-    return -2;
-
-  /* The depth of the outermost "fake" loop is -1.  This outermost
-     loop does not have a loop father and it is just a container, as
-     in the loop representation of GCC.  */
-  if (!LST_LOOP_FATHER (lst))
-    return -1;
-
-  return lst_depth (LST_LOOP_FATHER (lst)) + 1;
-}
-
-/* Returns the Dewey number for LST.  */
-
-static inline int
-lst_dewey_number (lst_p lst)
-{
-  int i;
-  lst_p l;
-
-  if (!lst)
-    return -1;
-
-  if (!LST_LOOP_FATHER (lst))
-    return 0;
-
-  FOR_EACH_VEC_ELT (LST_SEQ (LST_LOOP_FATHER (lst)), i, l)
-    if (l == lst)
-      return i;
-
-  return -1;
-}
-
-/* Returns the Dewey number of LST at depth DEPTH.  */
-
-static inline int
-lst_dewey_number_at_depth (lst_p lst, int depth)
-{
-  gcc_assert (lst && depth >= 0 && lst_depth (lst) <= depth);
-
-  if (lst_depth (lst) == depth)
-    return lst_dewey_number (lst);
-
-  return lst_dewey_number_at_depth (LST_LOOP_FATHER (lst), depth);
-}
-
-/* Returns the predecessor of LST in the sequence of its loop father.
-   Returns NULL if LST is the first statement in the sequence.  */
-
-static inline lst_p
-lst_pred (lst_p lst)
-{
-  int dewey;
-  lst_p father;
-
-  if (!lst || !LST_LOOP_FATHER (lst))
-    return NULL;
-
-  dewey = lst_dewey_number (lst);
-  if (dewey == 0)
-    return NULL;
-
-  father = LST_LOOP_FATHER (lst);
-  return LST_SEQ (father)[dewey - 1];
-}
-
-/* Returns the successor of LST in the sequence of its loop father.
-   Returns NULL if there is none.  */
-
-static inline lst_p
-lst_succ (lst_p lst)
-{
-  int dewey;
-  lst_p father;
-
-  if (!lst || !LST_LOOP_FATHER (lst))
-    return NULL;
-
-  dewey = lst_dewey_number (lst);
-  father = LST_LOOP_FATHER (lst);
-
-  if (LST_SEQ (father).length () == (unsigned) dewey + 1)
-    return NULL;
-
-  return LST_SEQ (father)[dewey + 1];
-}
-
-
-/* Return the LST node corresponding to PBB.  */
-
-static inline lst_p
-lst_find_pbb (lst_p lst, poly_bb_p pbb)
-{
-  int i;
-  lst_p l;
-
-  if (!lst)
-    return NULL;
-
-  if (!LST_LOOP_P (lst))
-    return (pbb == LST_PBB (lst)) ? lst : NULL;
-
-  for (i = 0; LST_SEQ (lst).iterate (i, &l); i++)
-    {
-      lst_p res = lst_find_pbb (l, pbb);
-      if (res)
-	return res;
-    }
-
-  return NULL;
-}
-
-/* Return the LST node corresponding to the loop around STMT at depth
-   LOOP_DEPTH.  */
-
-static inline lst_p
-find_lst_loop (lst_p stmt, int loop_depth)
-{
-  lst_p loop = LST_LOOP_FATHER (stmt);
-
-  gcc_assert (loop_depth >= 0);
-
-  while (loop_depth < lst_depth (loop))
-    loop = LST_LOOP_FATHER (loop);
-
-  return loop;
-}
-
-/* Return the first LST representing a PBB statement in LST.  */
-
-static inline lst_p
-lst_find_first_pbb (lst_p lst)
-{
-  int i;
-  lst_p l;
-
-  if (!lst)
-    return NULL;
-
-  if (!LST_LOOP_P (lst))
-    return lst;
-
-  for (i = 0; LST_SEQ (lst).iterate (i, &l); i++)
-    {
-      lst_p res = lst_find_first_pbb (l);
-      if (res)
-	return res;
-    }
-
-  return NULL;
-}
-
-/* Returns true when LST is a loop that does not contain
-   statements.  */
-
-static inline bool
-lst_empty_p (lst_p lst)
-{
-  return !lst_find_first_pbb (lst);
-}
-
-/* Return the last LST representing a PBB statement in LST.  */
-
-static inline lst_p
-lst_find_last_pbb (lst_p lst)
-{
-  int i;
-  lst_p l, res = NULL;
-
-  if (!lst)
-    return NULL;
-
-  if (!LST_LOOP_P (lst))
-    return lst;
-
-  for (i = 0; LST_SEQ (lst).iterate (i, &l); i++)
-    {
-      lst_p last = lst_find_last_pbb (l);
-
-      if (last)
-	res = last;
-    }
-
-  gcc_assert (res);
-  return res;
-}
-
-/* Returns true if LOOP contains LST, in other words, if LST is nested
-   in LOOP.  */
-
-static inline bool
-lst_contains_p (lst_p loop, lst_p lst)
-{
-  if (!loop || !lst || !LST_LOOP_P (loop))
-    return false;
-
-  if (loop == lst)
-    return true;
-
-  return lst_contains_p (loop, LST_LOOP_FATHER (lst));
-}
-
-/* Returns true if LOOP contains PBB, in other words, if PBB is nested
-   in LOOP.  */
-
-static inline bool
-lst_contains_pbb (lst_p loop, poly_bb_p pbb)
-{
-  return lst_find_pbb (loop, pbb) ? true : false;
-}
-
-/* Creates a loop nest of depth NB_LOOPS containing LST.  */
-
-static inline lst_p
-lst_create_nest (int nb_loops, lst_p lst)
-{
-  lst_p res, loop;
-  vec<lst_p> seq;
-
-  if (nb_loops == 0)
-    return lst;
-
-  seq.create (1);
-  loop = lst_create_nest (nb_loops - 1, lst);
-  seq.quick_push (loop);
-  res = new_lst_loop (seq);
-  LST_LOOP_FATHER (loop) = res;
-
-  return res;
-}
-
-/* Removes LST from the sequence of statements of its loop father.  */
-
-static inline void
-lst_remove_from_sequence (lst_p lst)
-{
-  lst_p father = LST_LOOP_FATHER (lst);
-  int dewey = lst_dewey_number (lst);
-
-  gcc_assert (lst && father && dewey >= 0);
-
-  LST_SEQ (father).ordered_remove (dewey);
-  LST_LOOP_FATHER (lst) = NULL;
-}
-
-/* Removes the loop LST and inline its body in the father loop.  */
-
-static inline void
-lst_remove_loop_and_inline_stmts_in_loop_father (lst_p lst)
-{
-  lst_p l, father = LST_LOOP_FATHER (lst);
-  int i, dewey = lst_dewey_number (lst);
-
-  gcc_assert (lst && father && dewey >= 0);
-
-  LST_SEQ (father).ordered_remove (dewey);
-  LST_LOOP_FATHER (lst) = NULL;
-
-  FOR_EACH_VEC_ELT (LST_SEQ (lst), i, l)
-    {
-      LST_SEQ (father).safe_insert (dewey + i, l);
-      LST_LOOP_FATHER (l) = father;
-    }
-}
-
-/* Sets NITER to the upper bound approximation of the number of
-   iterations of loop LST.  */
-
-static inline void
-lst_niter_for_loop (lst_p lst, mpz_t niter)
-{
-  int depth = lst_depth (lst);
-  poly_bb_p pbb = LST_PBB (lst_find_first_pbb (lst));
-
-  gcc_assert (LST_LOOP_P (lst));
-  pbb_number_of_iterations_at_time (pbb, psct_dynamic_dim (pbb, depth), niter);
-}
-
-/* Updates the scattering of PBB to be at the DEWEY number in the loop
-   at depth LEVEL.  */
-
-static inline void
-pbb_update_scattering (poly_bb_p pbb, graphite_dim_t level, int dewey)
-{
-  graphite_dim_t sched = psct_static_dim (pbb, level);
-  isl_space *d = isl_map_get_space (pbb->transformed);
-  isl_space *d1 = isl_space_range (d);
-  unsigned i, n = isl_space_dim (d1, isl_dim_out);
-  isl_space *d2 = isl_space_add_dims (d1, isl_dim_in, n);
-  isl_map *x = isl_map_universe (d2);
-
-  x = isl_map_fix_si (x, isl_dim_out, sched, dewey);
-
-  for (i = 0; i < n; i++)
-    if (i != sched)
-      x = isl_map_equate (x, isl_dim_in, i, isl_dim_out, i);
-
-  pbb->transformed = isl_map_apply_range (pbb->transformed, x);
-}
-
-/* Updates the scattering of all the PBBs under LST to be at the DEWEY
-   number in the loop at depth LEVEL.  */
-
-static inline void
-lst_update_scattering_under (lst_p lst, int level, int dewey)
-{
-  int i;
-  lst_p l;
-
-  gcc_assert (lst && level >= 0 && dewey >= 0);
-
-  if (LST_LOOP_P (lst))
-    for (i = 0; LST_SEQ (lst).iterate (i, &l); i++)
-      lst_update_scattering_under (l, level, dewey);
-  else
-    pbb_update_scattering (LST_PBB (lst), level, dewey);
-}
-
-/* Updates the all the scattering levels of all the PBBs under
-   LST.  */
-
-static inline void
-lst_update_scattering (lst_p lst)
-{
-  int i;
-  lst_p l;
-
-  if (!lst)
-    return;
-
-  if (LST_LOOP_FATHER (lst))
-    {
-      lst_p father = LST_LOOP_FATHER (lst);
-      int dewey = lst_dewey_number (lst);
-      int level = lst_depth (lst);
-
-      gcc_assert (lst && father && dewey >= 0 && level >= 0);
-
-      for (i = dewey; LST_SEQ (father).iterate (i, &l); i++)
-	lst_update_scattering_under (l, level, i);
-    }
-
-  if (LST_LOOP_P (lst))
-    for (i = 0; LST_SEQ (lst).iterate (i, &l); i++)
-      lst_update_scattering (l);
-}
-
-/* Inserts LST1 before LST2 if BEFORE is true; inserts LST1 after LST2
-   if BEFORE is false.  */
-
-static inline void
-lst_insert_in_sequence (lst_p lst1, lst_p lst2, bool before)
-{
-  lst_p father;
-  int dewey;
-
-  /* Do not insert empty loops.  */
-  if (!lst1 || lst_empty_p (lst1))
-    return;
-
-  father = LST_LOOP_FATHER (lst2);
-  dewey = lst_dewey_number (lst2);
-
-  gcc_assert (lst2 && father && dewey >= 0);
-
-  LST_SEQ (father).safe_insert (before ? dewey : dewey + 1, lst1);
-  LST_LOOP_FATHER (lst1) = father;
-}
-
-/* Replaces LST1 with LST2.  */
-
-static inline void
-lst_replace (lst_p lst1, lst_p lst2)
-{
-  lst_p father;
-  int dewey;
-
-  if (!lst2 || lst_empty_p (lst2))
-    return;
-
-  father = LST_LOOP_FATHER (lst1);
-  dewey = lst_dewey_number (lst1);
-  LST_LOOP_FATHER (lst2) = father;
-  LST_SEQ (father)[dewey] = lst2;
-}
-
-/* Returns a copy of ROOT where LST has been replaced by a copy of the
-   LSTs A B C in this sequence.  */
-
-static inline lst_p
-lst_substitute_3 (lst_p root, lst_p lst, lst_p a, lst_p b, lst_p c)
-{
-  int i;
-  lst_p l;
-  vec<lst_p> seq;
-
-  if (!root)
-    return NULL;
-
-  gcc_assert (lst && root != lst);
-
-  if (!LST_LOOP_P (root))
-    return new_lst_stmt (LST_PBB (root));
-
-  seq.create (5);
-
-  for (i = 0; LST_SEQ (root).iterate (i, &l); i++)
-    if (l != lst)
-      seq.safe_push (lst_substitute_3 (l, lst, a, b, c));
-    else
-      {
-	if (!lst_empty_p (a))
-	  seq.safe_push (copy_lst (a));
-	if (!lst_empty_p (b))
-	  seq.safe_push (copy_lst (b));
-	if (!lst_empty_p (c))
-	  seq.safe_push (copy_lst (c));
-      }
-
-  return new_lst_loop (seq);
-}
-
-/* Moves LST before LOOP if BEFORE is true, and after the LOOP if
-   BEFORE is false.  */
-
-static inline void
-lst_distribute_lst (lst_p loop, lst_p lst, bool before)
-{
-  int loop_depth = lst_depth (loop);
-  int depth = lst_depth (lst);
-  int nb_loops = depth - loop_depth;
-
-  gcc_assert (lst && loop && LST_LOOP_P (loop) && nb_loops > 0);
-
-  lst_remove_from_sequence (lst);
-  lst_insert_in_sequence (lst_create_nest (nb_loops, lst), loop, before);
-}
-
-/* Removes from LOOP all the statements before/after and including PBB
-   if BEFORE is true/false.  Returns the negation of BEFORE when the
-   statement PBB has been found.  */
-
-static inline bool
-lst_remove_all_before_including_pbb (lst_p loop, poly_bb_p pbb, bool before)
-{
-  int i;
-  lst_p l;
-
-  if (!loop || !LST_LOOP_P (loop))
-    return before;
-
-  for (i = 0; LST_SEQ (loop).iterate (i, &l);)
-    if (LST_LOOP_P (l))
-      {
-	before = lst_remove_all_before_including_pbb (l, pbb, before);
-
-	if (LST_SEQ (l).length () == 0)
-	  {
-	    LST_SEQ (loop).ordered_remove (i);
-	    free_lst (l);
-	  }
-	else
-	  i++;
-      }
-    else
-      {
-	if (before)
-	  {
-	    if (LST_PBB (l) == pbb)
-	      before = false;
-
-	    LST_SEQ (loop).ordered_remove (i);
-	    free_lst (l);
-	  }
-	else if (LST_PBB (l) == pbb)
-	  {
-	    before = true;
-	    LST_SEQ (loop).ordered_remove (i);
-	    free_lst (l);
-	  }
-	else
-	  i++;
-      }
-
-  return before;
-}
-
-/* Removes from LOOP all the statements before/after and excluding PBB
-   if BEFORE is true/false; Returns the negation of BEFORE when the
-   statement PBB has been found.  */
-
-static inline bool
-lst_remove_all_before_excluding_pbb (lst_p loop, poly_bb_p pbb, bool before)
-{
-  int i;
-  lst_p l;
-
-  if (!loop || !LST_LOOP_P (loop))
-    return before;
-
-  for (i = 0; LST_SEQ (loop).iterate (i, &l);)
-    if (LST_LOOP_P (l))
-      {
-	before = lst_remove_all_before_excluding_pbb (l, pbb, before);
-
-	if (LST_SEQ (l).length () == 0)
-	  {
-	    LST_SEQ (loop).ordered_remove (i);
-	    free_lst (l);
-	    continue;
-	  }
-
-	i++;
-      }
-    else
-      {
-	if (before && LST_PBB (l) != pbb)
-	  {
-	    LST_SEQ (loop).ordered_remove (i);
-	    free_lst (l);
-	    continue;
-	  }
-
-	i++;
-
-	if (LST_PBB (l) == pbb)
-	  before = before ? false : true;
-      }
-
-  return before;
-}
-
 /* A SCOP is a Static Control Part of the program, simple enough to be
    represented in polyhedral form.  */
 struct scop
@@ -1350,9 +384,6 @@ struct scop
      representation.  */
   vec<poly_bb_p> bbs;
 
-  /* Original, transformed and saved schedules.  */
-  lst_p original_schedule, transformed_schedule, saved_schedule;
-
   /* The context describes known restrictions concerning the parameters
      and relations in between the parameters.
 
@@ -1387,9 +418,6 @@ struct scop
 #define SCOP_BBS(S) (S->bbs)
 #define SCOP_REGION(S) ((sese) S->region)
 #define SCOP_CONTEXT(S) (NULL)
-#define SCOP_ORIGINAL_SCHEDULE(S) (S->original_schedule)
-#define SCOP_TRANSFORMED_SCHEDULE(S) (S->transformed_schedule)
-#define SCOP_SAVED_SCHEDULE(S) (S->saved_schedule)
 #define POLY_SCOP_P(S) (S->poly_scop_p)
 
 extern scop_p new_scop (void *);
@@ -1397,11 +425,6 @@ extern void free_scop (scop_p);
 extern void free_scops (vec<scop_p> );
 extern void print_generated_program (FILE *, scop_p);
 extern void debug_generated_program (scop_p);
-extern void print_scattering_function (FILE *, poly_bb_p, int);
-extern void print_scattering_functions (FILE *, scop_p, int);
-extern void debug_scattering_function (poly_bb_p, int);
-extern void debug_scattering_functions (scop_p, int);
-extern int scop_max_loop_depth (scop_p);
 extern int unify_scattering_dimensions (scop_p);
 extern bool apply_poly_transforms (scop_p);
 extern bool graphite_legal_transform (scop_p);
@@ -1430,114 +453,9 @@ scop_set_nb_params (scop_p scop, graphite_dim_t nb_params)
   scop->nb_params = nb_params;
 }
 
-/* Allocates a new empty poly_scattering structure.  */
-
-static inline poly_scattering_p
-poly_scattering_new (void)
-{
-  poly_scattering_p res = XNEW (struct poly_scattering);
-
-  res->nb_local_variables = 0;
-  res->nb_scattering = 0;
-  return res;
-}
-
-/* Free a poly_scattering structure.  */
-
-static inline void
-poly_scattering_free (poly_scattering_p s)
-{
-  free (s);
-}
-
-/* Copies S and return a new scattering.  */
-
-static inline poly_scattering_p
-poly_scattering_copy (poly_scattering_p s)
-{
-  poly_scattering_p res = poly_scattering_new ();
-
-  res->nb_local_variables = s->nb_local_variables;
-  res->nb_scattering = s->nb_scattering;
-  return res;
-}
-
-/* Saves the transformed scattering of PBB.  */
-
-static inline void
-store_scattering_pbb (poly_bb_p pbb)
-{
-  isl_map_free (pbb->saved);
-  pbb->saved = isl_map_copy (pbb->transformed);
-}
-
-/* Stores the SCOP_TRANSFORMED_SCHEDULE to SCOP_SAVED_SCHEDULE.  */
-
-static inline void
-store_lst_schedule (scop_p scop)
-{
-  if (SCOP_SAVED_SCHEDULE (scop))
-    free_lst (SCOP_SAVED_SCHEDULE (scop));
-
-  SCOP_SAVED_SCHEDULE (scop) = copy_lst (SCOP_TRANSFORMED_SCHEDULE (scop));
-}
-
-/* Restores the SCOP_TRANSFORMED_SCHEDULE from SCOP_SAVED_SCHEDULE.  */
-
-static inline void
-restore_lst_schedule (scop_p scop)
-{
-  if (SCOP_TRANSFORMED_SCHEDULE (scop))
-    free_lst (SCOP_TRANSFORMED_SCHEDULE (scop));
-
-  SCOP_TRANSFORMED_SCHEDULE (scop) = copy_lst (SCOP_SAVED_SCHEDULE (scop));
-}
-
-/* Saves the scattering for all the pbbs in the SCOP.  */
-
-static inline void
-store_scattering (scop_p scop)
-{
-  int i;
-  poly_bb_p pbb;
-
-  for (i = 0; SCOP_BBS (scop).iterate (i, &pbb); i++)
-    store_scattering_pbb (pbb);
-
-  store_lst_schedule (scop);
-}
-
-/* Restores the scattering of PBB.  */
-
-static inline void
-restore_scattering_pbb (poly_bb_p pbb)
-{
-  gcc_assert (pbb->saved);
-
-  isl_map_free (pbb->transformed);
-  pbb->transformed = isl_map_copy (pbb->saved);
-}
-
-/* Restores the scattering for all the pbbs in the SCOP.  */
-
-static inline void
-restore_scattering (scop_p scop)
-{
-  int i;
-  poly_bb_p pbb;
-
-  for (i = 0; SCOP_BBS (scop).iterate (i, &pbb); i++)
-    restore_scattering_pbb (pbb);
-
-  restore_lst_schedule (scop);
-}
-
 bool graphite_legal_transform (scop_p);
-isl_map *reverse_loop_at_level (poly_bb_p, int);
-isl_union_map *reverse_loop_for_pbbs (scop_p, vec<poly_bb_p> , int);
 __isl_give isl_union_map *extend_schedule (__isl_take isl_union_map *);
 
-
 void
 compute_deps (scop_p scop, vec<poly_bb_p> pbbs,
 	      isl_union_map **must_raw,
diff --git a/gcc/graphite-sese-to-poly.c b/gcc/graphite-sese-to-poly.c
index 4230f62051b..0df094432cf 100644
--- a/gcc/graphite-sese-to-poly.c
+++ b/gcc/graphite-sese-to-poly.c
@@ -482,18 +482,12 @@ isl_id_for_pbb (scop_p s, poly_bb_p pbb)
 /* Converts the STATIC_SCHEDULE of PBB into a scattering polyhedron.
    We generate SCATTERING_DIMENSIONS scattering dimensions.
 
-   CLooG 0.15.0 and previous versions require, that all
-   scattering functions of one CloogProgram have the same number of
-   scattering dimensions, therefore we allow to specify it.  This
-   should be removed in future versions of CLooG.
-
    The scattering polyhedron consists of these dimensions: scattering,
    loop_iterators, parameters.
 
    Example:
 
    | scattering_dimensions = 5
-   | used_scattering_dimensions = 3
    | nb_iterators = 1
    | scop_nb_params = 2
    |
@@ -514,15 +508,13 @@ isl_id_for_pbb (scop_p s, poly_bb_p pbb)
 
 static void
 build_pbb_scattering_polyhedrons (isl_aff *static_sched,
-				  poly_bb_p pbb, int scattering_dimensions)
+				  poly_bb_p pbb)
 {
   int i;
-  int nb_iterators = pbb_dim_iter_domain (pbb);
-  int used_scattering_dimensions = nb_iterators * 2 + 1;
   isl_val *val;
   isl_space *dc, *dm;
 
-  gcc_assert (scattering_dimensions >= used_scattering_dimensions);
+  int scattering_dimensions = isl_set_dim (pbb->domain, isl_dim_set) * 2 + 1;
 
   dc = isl_set_get_space (pbb->domain);
   dm = isl_space_add_dims (isl_space_from_domain (dc),
@@ -615,7 +607,6 @@ build_scop_scattering (scop_p scop)
     {
       gimple_bb_p gbb = PBB_BLACK_BOX (pbb);
       int prefix;
-      int nb_scat_dims = pbb_dim_iter_domain (pbb) * 2 + 1;
 
       if (previous_gbb)
 	prefix = nb_common_loops (SCOP_REGION (scop), previous_gbb, gbb);
@@ -626,7 +617,7 @@ build_scop_scattering (scop_p scop)
 
       static_sched = isl_aff_add_coefficient_si (static_sched, isl_dim_in,
 						 prefix, 1);
-      build_pbb_scattering_polyhedrons (static_sched, pbb, nb_scat_dims);
+      build_pbb_scattering_polyhedrons (static_sched, pbb);
     }
 
   isl_aff_free (static_sched);
@@ -3130,7 +3121,7 @@ rewrite_commutative_reductions_out_of_ssa (scop_p scop)
 }
 
 /* Can all ivs be represented by a signed integer?
-   As CLooG might generate negative values in its expressions, signed loop ivs
+   As ISL might generate negative values in its expressions, signed loop ivs
    are required in the backend. */
 
 static bool
@@ -3176,9 +3167,7 @@ build_poly_scop (scop_p scop)
 
   build_scop_bbs (scop);
 
-  /* FIXME: This restriction is needed to avoid a problem in CLooG.
-     Once CLooG is fixed, remove this guard.  Anyways, it makes no
-     sense to optimize a scop containing only PBBs that do not belong
+  /* Do not optimize a scop containing only PBBs that do not belong
      to any loops.  */
   if (nb_pbbs_in_loops (scop) == 0)
     return;
@@ -3210,7 +3199,6 @@ build_poly_scop (scop_p scop)
   rewrite_cross_bb_scalar_deps_out_of_ssa (scop);
 
   build_scop_drs (scop);
-  scop_to_lst (scop);
   build_scop_scattering (scop);
 
   /* This SCoP has been translated to the polyhedral
diff --git a/gcc/graphite.c b/gcc/graphite.c
index c53e588f947..b9974d2fedb 100644
--- a/gcc/graphite.c
+++ b/gcc/graphite.c
@@ -25,12 +25,7 @@ along with GCC; see the file COPYING3.  If not see
    An early description of this pass can be found in the GCC Summit'06
    paper "GRAPHITE: Polyhedral Analyses and Optimizations for GCC".
    The wiki page http://gcc.gnu.org/wiki/Graphite contains pointers to
-   the related work.
-
-   One important document to read is CLooG's internal manual:
-   http://repo.or.cz/w/cloog-ppl.git?a=blob_plain;f=doc/cloog.texi;hb=HEAD
-   that describes the data structure of loops used in this file, and
-   the functions that are used for transforming the code.  */
+   the related work.  */
 
 #include "config.h"
 
@@ -306,6 +301,9 @@ graphite_transform_loops (void)
 	scop->ctx = ctx;
 	build_poly_scop (scop);
 
+	if (dump_file && dump_flags)
+	  print_scop (dump_file, scop, 3);
+
 	if (POLY_SCOP_P (scop)
 	    && apply_poly_transforms (scop)
 	    && graphite_regenerate_ast_isl (scop))
@@ -346,10 +344,7 @@ gate_graphite_transforms (void)
 {
   /* Enable -fgraphite pass if any one of the graphite optimization flags
      is turned on.  */
-  if (flag_loop_block
-      || flag_loop_interchange
-      || flag_loop_strip_mine
-      || flag_graphite_identity
+  if (flag_graphite_identity
       || flag_loop_parallelize_all
       || flag_loop_optimize_isl)
     flag_graphite = 1;
-- 
